#!/usr/bin/env ruby
# frozen_string_literal: true

require "json"
require "open3"
require "fileutils"
require "shellwords"
require "time"

payload_raw = ENV.fetch("AGENT_SANDBOX_PAYLOAD")
payload = JSON.parse(payload_raw)

cmd = payload.fetch("cmd")
argv = payload["argv"]
cwd = payload.fetch("cwd")
timeout_seconds = payload["timeout_seconds"]

FileUtils.mkdir_p(cwd)

argv = if argv.nil? || argv.empty?
         Shellwords.split(cmd.to_s)
       else
         Array(argv).map(&:to_s)
       end

# Default timeout to prevent indefinite hangs (e.g., interactive prompts, stuck tests).
timeout_seconds = timeout_seconds.nil? ? Integer(ENV.fetch("AGENT_SANDBOX_TIMEOUT_SECONDS", "300")) : timeout_seconds.to_i

# Hard-disable interactive git prompts inside the sandbox.
env = {
  "GIT_TERMINAL_PROMPT" => "0",
  "GIT_SSH_COMMAND" => "ssh -o BatchMode=yes",
  # Prevent nested tool execution (e.g., running tool tests inside the sandbox can otherwise recurse).
  "AGENT_SANDBOX_ACTIVE" => "1",
  "AI_TOOLS_EXECUTE" => "false"
}

stdout = ""
stderr = ""
status = nil
pid = nil
timed_out = false

def kill_process_tree(pid)
  return if pid.nil?

  begin
    Process.kill("TERM", -pid)
  rescue Errno::ESRCH
    # Process group may not exist even if the pid does; fall back to single pid.
    begin
      Process.kill("TERM", pid)
    rescue Errno::ESRCH
      return
    end
  rescue Errno::EINVAL
    # Fall back to single pid.
    begin
      Process.kill("TERM", pid)
    rescue Errno::ESRCH
      return
    end
  end

  sleep 0.5

  begin
    Process.kill("KILL", -pid)
  rescue Errno::ESRCH
    # Group may not exist; try single pid (it might still be alive).
    begin
      Process.kill("KILL", pid)
    rescue Errno::ESRCH
      # already exited
    end
  rescue Errno::EINVAL
    begin
      Process.kill("KILL", pid)
    rescue Errno::ESRCH
      # already exited
    end
  end
end

begin
  started_at = Time.now.utc.iso8601
  deadline = Process.clock_gettime(Process::CLOCK_MONOTONIC) + timeout_seconds

  Open3.popen3(env, *argv, chdir: cwd, pgroup: true) do |stdin, out, err, wait_thr|
    stdin.close
    pid = wait_thr.pid

    out_buf = +""
    err_buf = +""
    out_eof = false
    err_eof = false

    # Non-blocking reads so we can enforce timeouts reliably on macOS.
    out.sync = true
    err.sync = true

    # Exit when we've drained stdout/stderr AND the child process has finished.
    # NOTE: `Process::Status#exitstatus` can be `nil` when the child was terminated by a signal,
    # so we must not use `exitstatus` as the loop terminator (it can cause an infinite loop).
    until (out_eof && err_eof) && status
      # Check for timeout.
      if Process.clock_gettime(Process::CLOCK_MONOTONIC) >= deadline
        timed_out = true
        kill_process_tree(pid)
      end

      # Drain available output.
      readable, = IO.select([out, err].compact, nil, nil, 0.1)
      Array(readable).each do |io|
        begin
          chunk = io.read_nonblock(16_384)
          if io == out
            out_buf << chunk
          else
            err_buf << chunk
          end
        rescue IO::WaitReadable
          next
        rescue EOFError
          out_eof = true if io == out
          err_eof = true if io == err
        end
      end

      # Check process status without racing `wait_thr` (which also waits/reaps).
      if wait_thr.join(0)
        status = wait_thr.value
      end

      break if timed_out && status
    end

    # Ensure we have a final status.
    status ||= wait_thr.value

    stdout = out_buf
    stderr = err_buf

    if timed_out
      stderr = "agent_sandbox_runner timeout after #{timeout_seconds}s (cmd=#{argv.join(" ")}, cwd=#{cwd})\n#{stderr}".strip
      status = Struct.new(:exitstatus).new(124)
    end
  ensure
    finished_at = Time.now.utc.iso8601
  end
rescue StandardError => e
  stderr = "agent_sandbox_runner error: #{e.class}: #{e.message}"
  status = Struct.new(:exitstatus).new(125)
end

print JSON.generate(
  status: status.exitstatus,
  stdout: stdout,
  stderr: stderr
)

exit(status.exitstatus)
