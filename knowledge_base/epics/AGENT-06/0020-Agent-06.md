### PRD 0020: Task Log Template & Persistence
**Overview**: Define a 12-section task log template for CWA operations (e.g., plan/execute/test/retry) and implement persistence using events.ndjson + run.json (from Epic 5 artifacts) or AiWorkflowRun model for structured traces/checkpoints. This enables auditability, failure recovery, and Junie pillars (traces/JSON outputs/checkpoints/graceful failures) in CWA workflows, tying to vision for traceable AI governance in family-office tools.

**Requirements**:
1) **Log Template**: Create a 12-section Markdown template (knowledge_base/templates/cwa_task_log.md) with sections: 1. Correlation ID/Task Summary, 2. Input Micro-Task (from context), 3. Plan (steps/tools), 4. Execute (tool calls/output), 5. Test (rake/rubocop/brakeman results), 6. Debug (failures/parsings), 7. Retry (fixes attempted), 8. Checkpoint (state snapshot), 9. Output Artifacts (files/commits), 10. Failure Analysis (if escalated), 11. Ball With/Ownership Update, 12. Final Status (resolved/blocked). CWA populates via gem callbacks (after_tool_call, after_turn).
2) **Persistence Mechanism**: Use file-based v1 (append to agent_logs/ai_workflow/<correlation_id>/events.ndjson for raw traces; serialize full log to run.json on completion); optional AiWorkflowRun model update (jsonb log field) if persistence needs querying. Ensure JSON outputs for checkpoints (e.g., {section: value}).
3) **Integration with Gem**: Hook into ai-agents lifecycle (e.g., after_handoff: init log, after_tool: append execute section); persist on each turn/checkpoint for resumability.
4) **Guardrails**: Max log size 100kB (truncate old turns); encrypt sensitive sections (e.g., artifacts paths via attr_encrypted if model used); graceful failure: If log fails, escalate with minimal trace in console.
5) **Non-Functional**: Logs persist locally; support 10-turn tasks without loss; <5s overhead per section; admin-viewable via future UI tab.
6) **Rails Guidance**: No new migrations v1 (file-only); if model, add jsonb :cwa_log to AiWorkflowRun; service AiLogService (app/services) for template rendering/appending (use JSONL for ndjson); callbacks in CWA agent registration.

**Architectural Context**: Builds on Epic 5 ai-agents framework: CWA agent callbacks trigger logging; context hash (correlation_id/state) from schema. Rails MVC for services; local Ollama/Grok/Claude via SmartProxy; RAG via context (include PRODUCT_REQUIREMENTS.md). Privacy: No cloud logs; RLS on model if added. Defer vector search—use file/JSON for traces.

**Acceptance Criteria**:
- CWA handoff → initializes 12-section log template in events.ndjson/run.json.
- Tool call → appends execute/test sections with outputs.
- Failure/retry → populates debug/retry/checkpoint, escalates if max retries.
- Completion → full log serialized, artifacts listed (e.g., generated files/commits).
- Resumability: Reload from run.json continues interrupted task.
- Size limit: Large log truncates gracefully without crash.
- Viewable: Console/rake shows log without errors.

**Test Cases**:
- Unit: MiniTest for AiLogService.append (mock callback, assert section added to ndjson/JSON).
- Integration: MiniTest/VCR for CWA task (cassette prompt; assert full log matches template, persists in files/model). Edge: Failure → failure analysis populated; max size → truncates.

**Workflow**: Junie: Pull from main, git checkout -b feature/prd-60b-log-persistence. Read <project root>/knowledge_base/prds/prds-junie-log/junie-log-requirement.md for logging. Ask questions (e.g., "Model vs file priority?") and build a plan in junie-log.md before coding. Use Claude Sonnet 4.5 default in RubyMine. Implement, test with MiniTest/VCR using real SmartProxy, commit only if green. Push branch for review.

