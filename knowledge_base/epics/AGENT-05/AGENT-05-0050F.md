# AGENT-05-0050F — Unified AI Routing & Live-Search Orchestration (Chatwoot + SmartProxy + SAP + AI Workflow)

## Overview
We currently have **multiple AI entry points** and **multiple decision layers**:
- `AiWorkflowService` (Chatwoot/`ai-agents` runner) uses `Agents.configure.default_model` (env-driven, e.g., `AI_DEFAULT_MODEL`).
- `SapAgent` has its own routing logic (`SapAgent::Router`) selecting `ollama` vs `grok-4`.
- “Live search” exists as SmartProxy `POST /proxy/tools` and is invoked explicitly (e.g., SAP `research: true`), while `/v1/chat/completions` is primarily a chat-completions proxy (and currently does not run a tool loop server-side).

This PRD unifies our approach so the **same model/tool selection policies** apply across:
- the SAP path,
- the Chatwoot agent workflow path,
- and any future “assistant” endpoints.

The goal is to reduce surprise, improve observability, and ensure we have a predictable framework for:
- “Which model should I use?”
- “Should I do live search?”
- “Who executes tools, and what does the caller receive?”

## Review Notes (Questions / Objections / Alternatives)
This section reflects review feedback against the latest draft.

### Key agreement
- A unified policy is necessary: today SAP has `SapAgent::Router`, while `AiWorkflowService` uses `AI_DEFAULT_MODEL`.
- We should make live search/tooling behavior explicit and observable across both SAP and Chatwoot/`ai-agents` workflows.

### Objections / risks
- **Server-side tool orchestration (Option B) increases coupling**: SmartProxy becomes responsible for tool execution correctness, tool safety, rate limiting, and replay/debug.
- **Cost/latency risk**: a multi-loop proxy-side tool orchestrator can add latency and incur paid requests; enforce loop caps and log loop counts.
- **Test brittleness**: “live” tests against external providers can be flaky; keep deterministic/unit tests in parallel even if we also run live smoke tests.

### Alternatives
- **Option A first** (client-side tool orchestration): keep SmartProxy focused on OpenAI-compat proxying; do tool loop in SAP/`ai-agents` runner. Then evolve to Option B later if we still want “single request → final answer” semantics.
- **Hybrid**: keep `/v1/chat/completions` pass-through but add a *new* endpoint like `/v1/orchestrated/chat/completions` that does the tool loop server-side.
- **Router model vs heuristics**: begin with the existing heuristic router (token threshold / `research: true`) and add a small “router prompt” model later if needed.

## Problem
1. **Inconsistent routing**: SAP uses `SapAgent::Router`, while `AiWorkflowService` defaults to `AI_DEFAULT_MODEL`.
2. **Live search ambiguity**: Live search is implemented (`/proxy/tools`) but not uniformly invoked; it may not be exercised in many flows.
3. **Tool orchestration ambiguity**: SmartProxy returns OpenAI-style responses but does not (today) guarantee “single request → tool execution → final response”.
4. **Observability gaps**: It’s hard to know (from logs/UI) why a model was chosen and whether live search was executed.

## Goals
- Provide a single “routing policy” component that decides:
  - model id (`ollama` vs `grok-4` vs other) and any fallbacks
  - whether live search should be invoked
  - whether tool execution is client-side or proxy-side
- Ensure the policy integrates cleanly with Chatwoot (`ai-agents`) workflow, SAP agent workflows, and future agents.
- Ensure decisions are visible in:
  - workflow artifacts (`agent_logs/ai_workflow/...`)
  - SAP logs (`agent_logs/sap.log`)
  - SmartProxy logs (`log/smart_proxy.log`)

## Non-Goals
- Building a full LangChain-style framework.
- Implementing a full RAG pipeline.
- Replacing `ai-agents`.

## Current State (as of 2026-01-02)
- Model selection:
  - `AiWorkflowService`: default from `AI_DEFAULT_MODEL` (`config/initializers/ai_agents.rb`).
  - `SapAgent`: `SapAgent::Router.route(payload)` chooses `ollama` vs `grok-4`.
- Live search:
  - Implemented in SmartProxy as `POST /proxy/tools`.
  - Used by SAP when `payload[:research]` is true (`SapAgent::ArtifactCommand` → `SapAgent::SmartProxyClient.research`).
- Tool-calls:
  - OpenAI tool-call schema can be returned to the client.
  - SmartProxy does not currently perform the tool loop internally.

## Requirements

### Functional
1. Introduce shared `AiRoutingPolicy` service at `app/services/ai/routing_policy.rb`.
   - Inputs:
     - `prompt` / `messages`
     - optional hints: `task_type`, `requires_live_data`, `privacy_level`, `max_cost_tier`
     - flags: `research_requested`
   - Outputs:
     - `model_id` (e.g., `ollama`, `grok-4`, `llama3.1:70b`)
     - `use_live_search` boolean
     - `reason` string
     - `policy_version`
2. Wrap/replace `SapAgent::Router.route(payload)` with `AiRoutingPolicy`.
3. Override `AiWorkflowService` model selection per-run using `AiRoutingPolicy` (rather than relying purely on `AI_DEFAULT_MODEL`).
4. **Standardize live search and tool orchestration**:
   - Adopt **Option B** (server-side orchestration in SmartProxy):
     - detect `tool_calls` responses from providers in `/v1/chat/completions`
     - execute supported tools internally (use the existing `/proxy/tools` logic)
     - append `role: tool` messages
     - re-call the model until `finish_reason="stop"`
     - enforce `max_loops=3` for safety
5. Provide a single high-level SAP entrypoint (example): `SapAgent.process(query)` returning:
   - `{ response:, tools_used:, model_used:, routing_reason:, loop_count: }`
6. Integrate with Chatwoot:
   - Chatwoot webhook → `AiWorkflowService` → policy decision → orchestrated response → post reply

### Non-Functional
- Latency targets:
  - router/policy < 5s
  - full loop < 20s (with max 3 loops)
- Privacy:
  - policy must support “high privacy” mode that forces local-only models (Ollama)
- Observability:
  - add a `routing_hint` header to SmartProxy requests (if useful)
  - log policy decision and tool calls as structured JSON

### Rails guidance
- Services live in `app/services/ai/*` and `app/services/sap_agent/*`.
- No migrations for v1.

### Logging
- Follow `knowledge_base/prds/prds-junie-log/junie-log-requirement.md`.
- Audit: `{timestamp, query_hash, policy_output, tools_invoked, final_model, loop_count}` in:
  - `agent_logs/sap.log`
  - workflow artifacts (`agent_logs/ai_workflow/<correlation_id>/events.ndjson`)

## Proposed Design

### 1) Introduce a shared routing policy module
Create a single place for routing decisions:
- `app/services/ai/routing_policy.rb` (or `app/services/ai_policy/router.rb`)

Input:
- `prompt` / `messages`
- optional hints: `task_type`, `requires_live_data`, `privacy_level`, `max_cost_tier`
- optional flags: `research_requested` (explicit)

Output:
- `model_id` (e.g., `ollama`, `grok-4`, `llama3.1:70b`)
- `use_live_search` boolean
- `reason` string (human-readable)
- `policy_version`

### 2) Unify SAP and AiWorkflowService to use the policy
- SAP:
  - Replace (or wrap) `SapAgent::Router.route(payload)` with the shared policy.
  - Preserve existing thresholds/heuristics but centralize them.
- AiWorkflowService:
  - Use routing policy output to override `Agents.config.default_model` for that run (or pass model in agent creation).
  - Record the decision as an `agent_logs/ai_workflow/<correlation_id>/events.ndjson` event (e.g., `type=routing_decision`).

### 3) Standardize live search behavior
We adopt **Option B** for the “official” architecture:
- SmartProxy performs the tool loop server-side and returns a final response.
- Enforce `max_loops=3`.
- Record tool usage + loop_count in logs.

### 4) Observability requirements
Every routing decision must be logged in structured form:
- SmartProxy: request + response log already exists; add `routing_hint` passthrough header if needed.
- SAP: log routing decision and whether research ran.
- AiWorkflow UI: show routing decision event in Logs.

### 5) Tests
Add tests that confirm:
- routing policy selects `ollama` for short/simple prompts
- routing policy selects `grok-4` for PRD/complex prompts
- routing policy selects `grok-4` and `use_live_search=true` when `research_requested=true`
- integration test: SAP path uses policy result and triggers live search
- integration test: AI workflow path records `routing_decision` in artifacts

Notes:
- This repo currently uses **Minitest** heavily; if we add RSpec, we should do so intentionally and consistently.

## Acceptance Criteria
1. **Single policy** decides model + live search for SAP and AI workflow paths.
2. **SmartProxy orchestration**: `/v1/chat/completions` supports tool loop (max 3 loops) and returns final response.
3. **Deterministic output**: policy decision is recorded and viewable in logs/UI.
4. **No regressions**: existing SAP behaviors continue to work.
5. **Test coverage**: policy unit tests + minimal integration coverage.

## Manual Test Plan
1. Run a small SAP prompt (no research) and verify routing chooses `ollama`.
2. Run a PRD prompt and verify routing chooses `grok-4`.
3. Run SAP with `research: true` and verify:
   - `/proxy/tools` was called
   - final response includes research results
4. Run `AiWorkflowService` with a prompt that triggers the policy and verify:
   - the `/admin/ai_workflow` logs show a `routing_decision` event

## Open Questions
- Do we want to enforce Option A (client-side) permanently, or implement Option B (proxy-side loop) for “single call” semantics?
- Do we want a “router model” (cheap) that chooses policy outputs, or keep heuristics?
- How do we express “privacy level” or “allowed providers” in the policy?
