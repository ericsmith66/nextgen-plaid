### PRD 0050B: Feedback & Resolution Loop

**Overview**: Extend ai-agents gem setup with feedback/resolution loops (e.g., Coordinator solicits input, resolves conflicts via handoffs), add guardrails (timeouts, `max_turns=5`), and route handoffs for groups/DM/broadcast (e.g., file/Redis wrapper). Enables iterative refinement in console, tying to vision for collaborative stewardship training.

**Requirements**:
1) **Feedback Loop**: In gem runner, add callback for Coordinator to request feedback (e.g., handoff back to SAP with `Resolve: [issue]`); persist loop state in context hash (`turns_count`, `feedback_history` array).
2) **Resolution Routing**: Use gem's hub-and-spoke for resolution (e.g., Coordinator decides final via `max_turns`); broadcast via metadata (e.g., `broadcast: all` → log to `agent_logs/`).
3) **FSM + Terminal States**: Track `context[:state]` with explicit terminal states: `resolved`, `blocked`, `escalated_to_human`, `awaiting_feedback`.
4) **Guardrails**: Configure gem `request_timeout=60s` (70b-friendly), `max_turns=5`; escalate-to-human on max turns/timeout with a clear console banner and an event written to `events.ndjson`.
5) **File/Redis Wrapper**: Start with file-based transport v1:
   - group/DM/broadcast metadata is written into `agent_logs/ai_workflow/<correlation_id>/events.ndjson`
   - Redis is optional later (only if needed)
6) **Non-Functional**: Loops resolve in <2min; support 3–5 turns without context loss; admin-gate rake tasks.
7) **Rails Guidance**: Update `AiWorkflowService` with loop methods (e.g., `.resolve_feedback`). Persistence can be file-based or via minimal `AiWorkflowRun` if resumability/UI requires it.

**Architectural Context**: Aligns with local Ollama/SmartProxy; RAG via context hash (include `PRODUCT_REQUIREMENTS.md`). Rails MVC for services; defer UI tracking.

**Acceptance Criteria**:
- Rake with feedback prompt → Coordinator hands off, resolves after 2 turns, updates ownership.
- Max turns hit → halts with “Escalate to human” banner.
- Broadcast: Group handoff logs to `agent_logs/` for all agents.
- Timeout: Long LLM call → guardrail errors gracefully.
- Context persists: Feedback history in output.
- No destructive actions: Whitelist blocks invalid tools.

**Test Cases**:
- Unit: MiniTest for `.resolve_feedback` (mock gem callbacks, assert `turns_count` increments).
- Task/Integration: MiniTest with deterministic `WebMock` stubs for SmartProxy multi-turn loop; assert resolution output and guardrail triggers. Edge: Stall → timeout; max turns → escalate.

**Workflow**: Junie: Pull from main, `git checkout -b feature/prd-50b-feedback-loop`. Read `<project root>/knowledge_base/prds/prds-junie-log/junie-log-requirement.md` for logging. Ask questions (e.g., “Redis vs file priority?”) and build a plan in `junie-log.md` before coding. Use Claude Sonnet 4.5 default in RubyMine. Implement, test with MiniTest/VCR, commit green. Push for review.
